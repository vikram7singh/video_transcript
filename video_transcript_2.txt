 All right, hey, so I'm Katrina. I'm here to talk about cogeneration. And I call this talk cogeneration go secret weapon because I think this is a really great and powerful technique. But it's one that I think is underutilized because it's a little bit tricky to get started with. And so my goal for this talk is to leave you guys with one and awareness that this exists and two, some building blocks that you can use when you go on your own cogeneration adventures. So accordingly, all the code from here is on GitHub. You can find it after the talk. A little bit about me, my name is Katrina. I'm a software engineer on the compute team at DigitalOcean. DigitalOcean is a cloud provider. We heard earlier today that we maybe shouldn't trust cloud providers. But DigitalOcean is specifically focused on improving developer happiness. So maybe we're a little less bad than everyone else. And a lot of our infrastructures are in and go. I specifically want to call your attention to these two open search projects that we have called Go QMU and Go LibVirt. These use code generation and these are great projects that my co-workers wrote that got me interested in talking about code generation today. They wrap these big sprawling C APIs with Go codes so that you can actually call them from within Go. So if you're interested in code generation production, check these two projects out there on GitHub too. All right, so code generation, what is it? 10,000 foot high level talk. You have a template. You've got some data. You've got some logic that's going to mash the template together with the data. You execute from the command line this Go Generate command. And voila, it produces some output for you. The format of the template is a Go text template, which you may be familiar with from other contexts. The format of the data is a Go interface. So pretty much anything you can mash to that template. And the format of the logic is Go code. So it should look really familiar to you if you've ever written Go before. And then the format of the output is anything at all. But we are going to focus today on producing output that is Go. So it's actual code that you can run elsewhere in your programs. But before we get started with that, let's do a little bit of a Hello World example. Just because, dude, 10,000 feet, let's go down to nets and bots. So here's a file that I'm going to use to generate some code. It's got everything we just talked about. It's got a template. It's got some data. Right now the data is empty because Hello World is the most basic possible example you could write. So we don't actually need any data. And we've got some logic that we're going to use to plug those two things together. Also, we just want to point out a little bit about the format of this file. This is a regular Go file. I've called it Gen.Go. You can call it anything you want. And like other Go files, I've written that this is in package main and this got a main function. But we're not going to run it the same way you normally run code that's in package main. Instead, I've added this tag, Go Generate. And this is going to tell the Go tool, hey, when we call it Go Generate, we want you to run Go Run Gen.Go. And that's what's going to call this code. So if we do that, then we'll produce some output file, Hello World. Great. The output file is called output.text, because that's the name that I put in the code generator. All right. That was what it actually does. But why would you ever want to use this? Anytime you're copying and pasting a lot, if you've got all that boilerplate code, and you're like, OK, I've got this line. Let me just change a couple of letters. Only copy and paste it. Change a couple of letters again. That's a time when you might want to use code generation. Especially if you anticipate that changing in the future, and you really don't want to be that person who has to maintain this code by going in and changing a couple of letters and copying and pasting a bunch of lines in the future. I personally think that the killer app is generating API clients and wrappers, like we've done with GoCube and Guilin. But it's also useful for other tasks. We were talking about an enumerated constants in the past. That's something that we've used code generation for before, so that you don't have to type all that out. All right. So accordingly, my next example is going to be about auto detecting JSON schemas from APIs that we consume. So here's a scenario. We've got some sort of rest API. Here in my example, I've taken this example from Instagram. We've got a user response. They were super creative, so I just left their field names in there. I've made a couple of modifications to this response. The most significant one is I took out anything nested, because this is a five minute talk and at the 45 minute talk, and if you want to talk about nesting, it's a lot more complicated. But this will do for us. So we want to take this JSON. We want to un-marshall it into a struct that way we can do something in our GoCode. And that looks something like this. We want to have some kind of goodness. Oh, we don't have any highlighting. Oh, you guys can see it, but I can't. Great. OK, cool. So we have some kind of user type. We want to un-marshall that data into the user type, and then we want to do stuff with this user. And so if we want to do this, we need a type that looks something like this that has all of those JSON fields. It translated into Go. And so this is the type of thing that's a little bit annoying, might be doing a lot of copying and pasting from JSON. And so we said, can we generate this type? And of course, it's a conference talk. So the answer is yes. And I'm going to give it a caveat, though, especially a modified version. We're going to make it a little bit simpler, just to make our lives easier. We're going to reorder the fields so that they're just in alphabetical order. That's easier for our generator. We're also going to use these ugly field names where it's sort of snake case. Normally, you would never do this in Go. You'd use camel casing and GoCode. But because it's generated code, normally, let things slide a little bit. And if you really care a whole lot, hey, you can write a snake case to camel case function. And then you can pass it to your template, and I'll show that how to do that next. All right. So here's the template. It's a little bit more complicated than the Hello World one. So I've put in its own file, template.tpl. I've also added this little disclaimer. Hey, this code was generated by GoGenerate. Do not edit it by hand. This will prevent a hapless developers after you from accidentally editing it and then having other changes gotten rid of next time GoGenerate runs. GoGenerate does not give you this automatically. You've got to add something like this yourself. We need to pass this template some information. One, we need to give it some data. In particular, we need to give it the name that we're going to call this struct. In this case, it's going to be user, because we're generating a user's type. We also need to give it the fields that are going to be in this struct. And so this is going to be the map of the JSON names and the values from that original JSON file. We're going to take that and we're going to spit out things that look like ID, string, username, string, et cetera. In order to do that, we have some functions title, which is going to title case, aka capitalize, the first letter of things, because if we're using a struct that to un-mercial JSON, if we're using a struct or un-mercial JSON, the fields all have to be exported. Otherwise, the JSON un-mercial can't find it. We're going to also have a type of function that's going to go from a value to a type. So this is going from like 1, 2, 3, 4, 5 to an integer, or in this case, a string, because that's what the API is using. All right. So here's the code that actually injects stuff into this file or into that template. Here's the place where we define the template. We load template.tpl and we give it this title and type of functions. If you're a purist, we can go out for beer after and you we can argue about whether or not I should have functions in my template where we're being pragmatic here. So we're going to pass those functions along to the template and we're going to allow them to operate there. We also have the data. In this case, we've got the name, which is user, and we've got all those fields, which is coming from this JSON response. And we have the place where all that data is loaded from whatever format that we got it in, in this case, JSON, into a generic map so that we can pass it onto the generator code. And finally, we have the place where it all gets matched together and generated. And I've called this file user.gen.go. I usually call outputs of generated code, something suffix with that gen.go, just so that it's easier for people to understand that it was generated and not something that they produced themselves. But it runs the same way as a go file does. All right. So we run go generate and voila, here's the output. Here's our user struct. It's got all the fields we wanted. It's got the formats we wanted. It's got, it indicates that it maps those JSON files or to those JSON fields, excuse me. And we can use it the way that we wanted to. We've got some type. In this case, it's called codegen.user because I put the output in a package that I call codegen. And we can, on martial JSON, enter it. And then we can do stuff like we can print it out. And we can see that the field names in this struct are the exact same field name that I generated. So this was a super basic example. But in summary, you can use code generation to create go code with go code. So this is super powerful and cool. This can replace a lot of annoying to maintain. That requires a lot of copying and pasting in your code base. All right. That's it. Thanks so much. Thank you. Thank you. Thank you. Thank you. Thank you. Thank you. Thank you. Thank you. Thank you.